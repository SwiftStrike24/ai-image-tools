You are an expert in TypeScript, Node.js, Next.js 14 App Router, React, Shadcn UI, Radix UI, Tailwind CSS, and Framer Motion.

Code Style and Structure
- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Structure files: exported component, subcomponents, helpers, static content, types.
- Prioritize using existing files, especially for API routes in src/app/api folder, unless a new file is absolutely necessary for maintainability or separation of concerns.
- Always consider maintainability, manageability, and scalability when organizing code and creating new files or components.

Naming Conventions
- Use lowercase with dashes for directories (e.g., components/auth-wizard).
- Favor named exports for components.

TypeScript Usage
- Use TypeScript for all code; prefer interfaces over types.
- Avoid enums; use maps instead.
- Use functional components with TypeScript interfaces.

Syntax and Formatting
- Use the "function" keyword for pure functions.
- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements.
- Use declarative JSX.
- Escape single quotes in JSX with &apos;, &lsquo;, &#39;, or &rsquo;.

UI and Styling
- Use Shadcn UI, Radix UI, and Tailwind CSS for components and styling.
- Implement responsive design with Tailwind CSS; use a mobile-first approach.
- Utilize custom components like ShimmerButton, AnimatedCheckmark, and GridPattern.
- Implement Framer Motion for animations and transitions.

Navigation and Layout
- Use the Dock component for consistent navigation across pages.
- Implement smooth scrolling for in-page navigation.
- Use Next.js Link component for client-side routing.

Performance Optimization
- Minimize 'use client', 'useEffect', and 'setState'; favor React Server Components (RSC).
- Wrap client components in Suspense with fallback.
- Use dynamic loading for non-critical components.
- Optimize images: use WebP format, include size data, implement lazy loading.
- Implement virtualization for long lists using react-virtualized or react-window.

Error Handling
- Use try-catch blocks for async operations, especially in server actions.
- Provide user-friendly error messages using the toast component.
- Implement error boundaries for client-side error handling.

State Management
- Use React hooks for local state management.
- Implement useReducer for complex state logic.
- Use Vercel KV (Redis) for server-side state persistence.

API Integration
- Use server actions for data fetching and mutations.
- Implement proper error handling and loading states for API calls.
- Use the Replicate API for AI image generation and upscaling.

Authentication
- Use Clerk for user authentication and authorization.
- Implement proper access control in server actions and API routes.

Key Conventions
- Use 'nuqs' for URL search parameter state management.
- Optimize Web Vitals (LCP, CLS, FID).
- Limit 'use client':
  - Favor server components and Next.js SSR.
  - Use only for Web API access in small components.
  - Avoid for data fetching or state management.

Testing
- Implement unit tests for utility functions and hooks.
- Use React Testing Library for component testing.
- Implement end-to-end tests using Cypress or Playwright.

SEO and Analytics
- Implement proper meta tags and structured data for SEO.
- Use Vercel Analytics and Speed Insights for performance monitoring.

Accessibility
- Ensure all interactive elements are keyboard accessible.
- Use proper ARIA attributes where necessary.
- Implement focus management for modals and dialogs.

Custom Components and Features
- Use the Dock component for navigation, with hover effects and labels.
- Implement AnimatedGradientText for eye-catching headers.
- Use GridPattern for background visual effects.
- Implement BlurFade for smooth transitions between sections.
- Use MagicCard for visually appealing card components.
- Implement shadcn or magicui components for interactive and visually engaging buttons and other UI elements, like shimmer button, animated checkmark, etc.

Pricing and Subscription
- Use Stripe for handling payments and subscriptions.
- Implement a clear pricing structure with feature comparisons.
- Use dialogs for confirming subscription changes or downgrades.

Landing Page
- Implement a visually appealing and informative landing page.
- Use animations and transitions to enhance user experience.
- Include sections for features, how-to guides, and FAQs.

Follow Next.js docs for Data Fetching, Rendering, and Routing.

Subscription and Pricing:
- Robust subscription management with Stripe API
- Redis for caching subscription data and managing pending downgrades
- Clear UI for subscription information
- Proper handling of subscription changes
- Stripe webhooks for data synchronization

State Management and Data Persistence:
- React hooks for local state, Redis for server-side persistence
- Error handling and loading states for API calls and state updates
- Supabase for long-term data storage

Authentication and Authorization:
- Clerk for user authentication and authorization
- Proper access control and handling of unauthenticated states

API Routes and Server Actions:
- Logical organization of API routes
- Use of server actions for data mutations
- Consistent error handling and response formatting

UI Components:
- Shadcn UI and Radix UI for consistent design
- Responsive designs with Tailwind CSS
- Framer Motion for animations

Performance Optimization:
- Efficient caching with Redis
- React Server Components
- Optimized API calls and database queries

Testing and Error Handling:
- Comprehensive error handling
- User-friendly error messages
- Unit tests for critical logic

Webhook Handling:
- Robust handling of Stripe events
- Idempotency in webhook processing
- Logging of webhook events

Code Organization:
- Centralized subscription logic
- Consistent naming conventions
- Reusable helper functions

Security:
- Proper authentication and authorization
- Use of environment variables
- Rate limiting on API routes

Logging and Monitoring:
- Comprehensive logging
- Error tracking services

Additional Performance Optimization
- Use dynamic imports for non-critical components to reduce initial bundle size.
- Implement lazy loading for images and videos to improve initial load time.
- Use React.memo() for components that don't need frequent re-renders.
- Implement debouncing for input handlers to reduce unnecessary state updates.
- Preload key assets using <link rel="preload"> to improve rendering time.
- Minimize main thread blocking operations, especially during initial load.
- Analyze and optimize JavaScript bundle size, importing only necessary parts of libraries.
- Use the useCallback hook for functions passed as props to child components.

Enhanced Component Design
- Create modular, reusable components to improve maintainability and reduce code duplication.
- Use custom hooks to extract complex logic from components.
- Implement proper prop typing for all components.

Continuous Optimization
- Always prioritize performance, user experience, and code maintainability when implementing new features or components.
- Regularly review and optimize existing code to ensure the app remains fast and efficient as it grows.